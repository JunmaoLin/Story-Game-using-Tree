import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.zip.DataFormatException;

/**
 * This class represents the primary data structure for the Zork game.
*/

public class StoryTree {
    private StoryTreeNode root = new StoryTreeNode("root", "root", "Hello, and welcome to Zork!");
    private StoryTreeNode cursor = root;
    private GameState state;

    /**
     * This is the constructor of the class.
     */
    public StoryTree(){}

    /**
     * Reads in a text file describing a StoryTree.
     * @param filename
     * Name of the file to read from.
     * @return
     * A new StoryTree generated by the passed in text file is returned.
     * @throws IllegalArgumentException
     * filename is empty or null.
     * @throws DataFormatException
     */
    public static StoryTree readTree(String filename) throws IllegalArgumentException, DataFormatException{
        if(filename == null || filename.trim().length() == 0){
            throw new IllegalArgumentException("Filename is empty or null");
        }
        StoryTree storyTree = new StoryTree();
        try {
            Scanner fileIn = new Scanner(new File(filename));
            while(fileIn.hasNextLine()) {
                String currentLine = fileIn.nextLine();
                String[] positionOptionMessage = currentLine.split(" \\| ");
                String[] positions = positionOptionMessage[0].split("-");
                StoryTreeNode currentNode = new StoryTreeNode(positionOptionMessage[0], positionOptionMessage[1], positionOptionMessage[2]);
                try{
                    storyTree.resetCursor();
                    StoryTreeNode temp = storyTree.getCursor();
                    for(int i = 0; i < positions.length; i++){
                        if(positions[i].equals("1")){
                            if(i == positions.length-1){
                                temp.setLeftChild(currentNode);
                            }
                            temp = temp.getLeftChild();
                        }
                        else if(positions[i].equals("2")){
                            if(i == positions.length-1){
                                temp.setMiddleChild(currentNode);
                            }
                            temp = temp.getMiddleChild();
                        }
                        else if(positions[i].equals("3")){
                            if(i == positions.length-1){
                                temp.setRightChild(currentNode);
                            }
                            temp = temp.getRightChild();
                        }
                    }
                    //temp = currentNode;
                } catch (Exception e){
                    throw new DataFormatException("The file contained data inconsistent with the expected data format ");
                }
            }
            
            fileIn.close();
            
        } catch (FileNotFoundException fnfe) {
            throw new IllegalArgumentException("");
        }
        return storyTree;
    }

    /**
     * Saves a StoryTree to the indicated file using the specified data format 
     * @param filename
     *  Name of the file to read from.
     * @param tree
     *  A reference to the tree to save to the indicated file.
     * @throws IllegalArgumentException
     *  filename is empty or null.
     *  tree is null.
     * @throws DataFormatException
     */
    public static void saveTree(String filename, StoryTree tree) throws IllegalArgumentException, DataFormatException{
        if(filename == null || filename.length() == 0 || tree == null){
            throw new IllegalArgumentException("filename is empty or null or tree is null.");
        }
        tree = StoryTree.readTree(filename);
    } 

    /**
     * This is the getter for the cursor
     * @return
     *  StoryTreeNode
     */
    public StoryTreeNode getCursor(){
        return this.cursor;
    }
    
    /**
     * This is the setter for the cursor
     * @param node
     */
    public void setCursor(StoryTreeNode node){
        this.cursor = node;
    }

    /**
     * This is the getter for the GameState
     * @return
     *  a GameState
     */
    public GameState getGameState() {
        return this.state;
    }

    /**
     * This is the getter for cursor position
     * @return
     * A String
     */
    public String getCursorPosition(){
        if(cursor == null){
            return "Current position is null.";
        }
        return cursor.getPosition();
    }

    public void positionHelper(StoryTreeNode root, String position){// start position with 1
        if(root == null){
            return;
        }
        root.setPosition(position);
        positionHelper(root.getLeftChild(), position + "-1");
        positionHelper(root.getMiddleChild(), position + "-2");
        positionHelper(root.getRightChild(), position + "-3");
    }

    /**
     * Gets the current message of the cursor.
     * @return
     *  a String
     */
    public String getCursorMessage(){
        return cursor.getMessage();
    }

    /**
     * Returns an array of String pairs - {position, option} for each immediate child of the cursor.
     * @return
     * a String pairs
     */
    public String[][] getOptions(){
        int amountOfChildren = 0;
        if(cursor.getLeftChild() != null){
            amountOfChildren++;
        }
        if(cursor.getMiddleChild() != null){
            amountOfChildren++;
        }
        if(cursor.getRightChild() != null){
            amountOfChildren++;
        }
        String[][] options = new String[amountOfChildren][2];
        for(int i = 0; i < options.length; i++){
            if(i == 0){
                options[0][0] = cursor.getLeftChild().getPosition();
                options[0][1] = cursor.getLeftChild().getOption();
            }
            else if(i == 1){
                options[1][0] = cursor.getMiddleChild().getPosition();
                options[1][1] = cursor.getMiddleChild().getOption();
            }
            else if(i == 2){
                options[2][0] = cursor.getRightChild().getPosition();
                options[2][1] = cursor.getRightChild().getOption();
            }
        }
        return options;
    }

    /**
     * Sets the message for the current cursor.
     * @param message
     */
    public void setCursorMessage(String message){
        cursor.setMessage(message);
    }

    /**
     * Sets the option for the current cursor.
     * @param option
     */
    public void setCursorOption(String option){
        cursor.setOption(option);
    }

    /**
     * Resets the cursor to the root node.
     */
    public void resetCursor(){
        cursor = root;
    }

    /**
     * Selects the child with the name indicated by position.
     * @param position
     *  The position String of the child to node to select.
     * @throws InvalidArgumentException
     *  position is empty or null.
     * @throws NodeNotPresentException
     *  Node with indicated position variable was not found.
     */
    public void selectChild(String position) throws InvalidArgumentException, NodeNotPresentException{
        if(position == null || position.equals("")){
            throw new InvalidArgumentException("position is empty or null.");
        }
        String[] positions = position.trim().split("-");
        StoryTreeNode temp = cursor;
        boolean flag = false;

        if(positions[positions.length-1].equals("1")){
            if(cursor.getLeftChild() == null){
                throw new NodeNotPresentException("child does not exist.");
            }
            cursor = cursor.getLeftChild();
            flag = true;
        }
        else if(positions[positions.length-1].equals("2")){
            if(cursor.getMiddleChild() == null){
                throw new NodeNotPresentException("child does not exist.");
            }
            cursor = cursor.getMiddleChild();
            flag = true;
        }
        else if(positions[positions.length-1].equals("3")){
            if(cursor.getRightChild() == null){
                throw new NodeNotPresentException("child does not exist.");
            }
            cursor = cursor.getRightChild();
            flag = true;
        }
        if(!flag){
            throw new NodeNotPresentException("Node with indicated position variable was not found.");
        }
    }

    /**
     * Adds a new child under the current cursor, with given option and message.
     * @param option
     *  The new String to set as the option of the new child.
     * @param message
     *  The new String to set as the message of the new child.
     * @throws InvalidArgumentException
     *  Either String is empty or null.
     * @throws TreeFullException
     *  All three child spots are already full.
     */
    public void addChild(String option, String message) throws InvalidArgumentException, TreeFullException{
        if(option == null || message == null || option.length() == 0 || message.length() == 0){
            throw new InvalidArgumentException("A String is either empty or null.");
        }
        if(cursor.isWinningNode() || cursor.isLosingNode()){
            throw new TreeFullException("End of game.");
        }
        if(cursor.getLeftChild() == null){
            cursor.setLeftChild(new StoryTreeNode(cursor.getPosition() + "-1", option, message));
        }
        else if(cursor.getMiddleChild() == null){
            cursor.setMiddleChild(new StoryTreeNode(cursor.getPosition() + "-2", option, message));
        }
        else if(cursor.getRightChild() == null){
            cursor.setRightChild(new StoryTreeNode(cursor.getPosition() + "-3", option, message));
        }
        else {
            throw new TreeFullException("All three child spots are already full.");
        }
    }

    /**
     * Removes an immediate child under the current cursor.
     * @param position
     *  String indicating the position of the child to be removed.
     * @return
     *  A reference to the child removed (along with it's attached sub-tree).
     * @throws NodeNotPresentException
     *  Node with indicated position variable was not found.
     */
    public StoryTreeNode removeChild(String position) throws NodeNotPresentException{
        String[] positions = position.split("-");
        StoryTreeNode temp = null;
        boolean flag = false;
        //System.out.println(positions[positions.length-1]);
        if(positions[positions.length-1].equals("1")){
            temp = cursor.getLeftChild();
            if(temp == null){
                throw new NodeNotPresentException("child does not exist.");
            }
            cursor.setLeftChild(cursor.getMiddleChild());
            cursor.setMiddleChild(cursor.getRightChild());
            cursor.setRightChild(null);
            flag = true;
        }
        else if(positions[positions.length-1].equals("2")){
            temp = cursor.getMiddleChild();
            if(temp == null){
                throw new NodeNotPresentException("child does not exist.");
            }
            cursor.setMiddleChild(cursor.getRightChild());
            cursor.setRightChild(null);
            flag = true;
        }
        else if(positions[positions.length-1].equals("3")){
            temp = cursor.getRightChild();
            if(temp == null){
                throw new NodeNotPresentException("child does not exist.");
            }
            cursor.setRightChild(null);
            flag = true;
        }
        if(!flag){
            throw new NodeNotPresentException("Node with indicated position variable was not found.");
        }
        else{
            positionHelper(root.getLeftChild(), "1");
            return temp;
        }
        
    }
}